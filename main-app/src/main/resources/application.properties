spring.application.name=spring-digital-library

# ===============================
# НАСТРОЙКИ СЕРВЕРА
# ===============================

# Например: Authorization, X-Requested-With, Content-Type, Accept и т.д.
server.forward-headers-strategy=framework

# ===============================
# НАСТРОЙКИ ПОДКЛЮЧЕНИЯ К БАЗЕ ДАННЫХ
# ===============================

# Настройки БД можно переопределить через переменные окружения:
# SPRING_DATASOURCE_URL, SPRING_DATASOURCE_USERNAME, SPRING_DATASOURCE_PASSWORD
# Или через .env файл в корне проекта
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/spring_digital_bookstore}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:admin}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:admin}

# ===============================
# НАСТРОЙКИ JPA / HIBERNATE
# ===============================

# Явно указываем диалект SQL для PostgreSQL.
# Hibernate будет:
# - использовать правильные типы данных
# - корректно создавать auto-increment поля
# - генерировать совместимые SQL-запросы
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Управляет генерацией схемы БД при старте приложения
# create       — ❗ УДАЛЯЕТ таблицы и создает заново
# update       — добавляет недостающие колонки (DEV)
# validate     — проверяет, но не создаёт
# none         — вообще ничего не делает
spring.jpa.hibernate.ddl-auto=create

# ===============================
# ЛОГИ SQL (ТОЛЬКО ДЛЯ DEV!)
# ===============================

# Показывает SQL-запросы, которые Hibernate отправляет в БД
# Например: CREATE TABLE, SELECT, INSERT
spring.jpa.show-sql=false

# Форматирует SQL-запросы в логах
# Без этого они идут в одну строку
spring.jpa.properties.hibernate.format_sql=true

# ===============================
# НАСТРОЙКИ ЛОГИРОВАНИЯ
# ===============================

# Уровень логирования для всего приложения (TRACE, DEBUG, INFO, WARN, ERROR)
logging.level.root=INFO

# Уровень логирования для StripeService (INFO для важных событий оплаты)
logging.level.online.ityura.springdigitallibrary.service.StripeService=INFO

# Логирование для отслеживания отправки событий в Kafka
logging.level.online.ityura.springdigitallibrary.service.KafkaProducerService=WARN
logging.level.online.ityura.springdigitallibrary.controller.BookController=INFO

# Уменьшаем логирование Kafka - убираем избыточные логи при недоступности
logging.level.org.apache.kafka=WARN
logging.level.org.springframework.kafka=WARN
logging.level.org.springframework.kafka.listener=WARN
logging.level.org.springframework.kafka.core=WARN

# ===============================
# ELK STACK НАСТРОЙКИ
# ===============================

# Включить/выключить отправку логов в Logstash
# По умолчанию отключено для локальной разработки (без ELK стека)
# Установите LOGSTASH_ENABLED=true или logging.logstash.enabled=true для включения
logging.logstash.enabled=${LOGSTASH_ENABLED:false}
# Хост Logstash (можно переопределить через переменную окружения LOGSTASH_HOST)
logging.logstash.host=${LOGSTASH_HOST:logstash}
# Порт Logstash (можно переопределить через переменную окружения LOGSTASH_PORT)
logging.logstash.port=${LOGSTASH_PORT:5000}

# ===============================
# JWT НАСТРОЙКИ
# ===============================

jwt.secret=${JWT_SECRET:MySuperSecretKeyForJWTsWhichShouldBeLongEnough}
# 5 minutes (300000 milliseconds = 5 * 60 * 1000)
jwt.expiration=300000
# 24 hours (86400000 milliseconds = 24 * 60 * 60 * 1000)
jwt.refresh-expiration=86400000

# ===============================
# SWAGGER / OPENAPI НАСТРОЙКИ
# ===============================

springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha

# ===============================
# OPENAI API НАСТРОЙКИ
# ===============================

# OpenAI API ключ
# Можно переопределить через переменную окружения OPENAI_API_KEY
# ВАЖНО: Не коммитьте реальный ключ в репозиторий! Используйте переменную окружения.
openai.api.key=${OPENAI_API_KEY:here_should_be_your_real_openai_api_key}

# ===============================
# GEMINI API НАСТРОЙКИ
# ===============================

# Google Gemini API ключ
# Можно переопределить через переменную окружения GEMINI_API_KEY
# ВАЖНО: Не коммитьте реальный ключ в репозиторий! Используйте переменную окружения.
gemini.api.key=${GEMINI_API_KEY:here_should_be_your_real_gemini_api_key}




# ===============================
# НАСТРОЙКИ ЗАГРУЗКИ ФАЙЛОВ
# ===============================

# Максимальный размер файла (5MB)
spring.servlet.multipart.max-file-size=5MB
spring.servlet.multipart.max-request-size=5MB

# ===============================
# НАСТРОЙКИ ПУТЕЙ ДЛЯ ИЗОБРАЖЕНИЙ КНИГ
# ===============================

# Путь для хранения изображений книг
# По умолчанию: путь для Windows (для локальной разработки)
# Можно переопределить через переменную окружения APP_IMAGES_STORAGE_PATH
# В Docker контейнере переменная APP_IMAGES_STORAGE_PATH автоматически устанавливается в /opt/spring-digital-bookstore/pictures
# Spring Boot также автоматически преобразует переменную окружения APP_IMAGES_STORAGE_PATH в app.images.storage-path
app.images.storage-path=${APP_IMAGES_STORAGE_PATH:G:\\opt\\spring-digital-bookstore\\pictures}

# ===============================
# НАСТРОЙКИ ПУТЕЙ ДЛЯ PDF ФАЙЛОВ КНИГ
# ===============================

# Путь для хранения PDF файлов книг
# По умолчанию: путь для Windows (для локальной разработки)
# Можно переопределить через переменную окружения APP_PDF_STORAGE_PATH
# В Docker контейнере переменная APP_PDF_STORAGE_PATH автоматически устанавливается в /opt/spring-digital-bookstore/pdf
# Spring Boot также автоматически преобразует переменную окружения APP_PDF_STORAGE_PATH в app.pdf.storage-path
app.pdf.storage-path=${APP_PDF_STORAGE_PATH:G:\\opt\\spring-digital-bookstore\\pdf}

# ===============================
# TELEGRAM BOT НАСТРОЙКИ
# ===============================

# Telegram Bot Token (можно переопределить через переменную окружения TELEGRAM_BOT_TOKEN)
# ВАЖНО: Не коммитьте реальный токен в репозиторий! Используйте переменную окружения.
telegram.bot.token=${TELEGRAM_BOT_TOKEN:here_should_be_your_real_telegram_bot_token}

# Telegram Chat ID - ID чата, куда будут отправляться сообщения
# ВАЖНО: Это должен быть Chat ID пользователя (ваш личный Chat ID), а НЕ ID бота!
# Получить Chat ID можно:
# 1. Написав /start боту @userinfobot - он покажет ваш Chat ID
# Можно переопределить через переменную окружения TELEGRAM_CHAT_ID
telegram.bot.chat-id=${TELEGRAM_CHAT_ID:here_should_be_your_real_telegram_chat_id}

# ===============================
# STRIPE НАСТРОЙКИ
# ===============================

# Stripe Secret Key (можно переопределить через переменную окружения STRIPE_SECRET_KEY)
# ВАЖНО: Не коммитьте реальный ключ в репозиторий! Используйте переменную окружения.
stripe.secret-key=${STRIPE_SECRET_KEY:sk_test_51Sn9eKF06mQasm4mhBSG71Wes6rz09BTuQicIu37oRIw5agFgZuGMGZQk4IeftRm2aQGJXFma5IPwm1iT77WlALs00VDZNJkEL}

# Stripe Webhook Secret (для проверки подлинности webhook событий)
# Можно переопределить через переменную окружения STRIPE_WEBHOOK_SECRET
# Получите этот секрет после создания webhook в Stripe Dashboard
# Он начинается с whsec_...
stripe.webhook-secret=${STRIPE_WEBHOOK_SECRET:whsec_5fEnfDkS3J2HtCmufHLLasm7ucyxk0UK}

# URL для успешной оплаты (redirect после оплаты)
# Используйте ваш внешний IP вместо localhost, если настраиваете проброс портов
stripe.success-url=${STRIPE_SUCCESS_URL:http://localhost:8080/api/v1/payment/success}

# URL для отмены оплаты (redirect при отмене)
# Используйте ваш внешний IP вместо localhost, если настраиваете проброс портов
stripe.cancel-url=${STRIPE_CANCEL_URL:http://localhost:8080/api/v1/payment/cancel}

# Время ожидания webhook перед применением fallback (в миллисекундах)
# По умолчанию 2000 мс (2 секунды). Webhook обычно приходит очень быстро.
# Если установить 0, fallback будет применяться сразу без ожидания
stripe.webhook-wait-timeout-ms=${STRIPE_WEBHOOK_WAIT_TIMEOUT_MS:2000}

# Frontend URL для редиректа после успешной оплаты (для UI)
# ОБЯЗАТЕЛЬНО для редиректа на страницу книги после оплаты
# Если не указан, будет возвращаться JSON ответ вместо редиректа
# Пример: http://localhost:3000 или https://yourdomain.com
app.frontend-url=${FRONTEND_URL:http://localhost:3000}

# ===============================
# KAFKA НАСТРОЙКИ
# ===============================

# Включить/выключить Kafka (по умолчанию включен)
# Если установить в false, приложение будет работать без аналитики
kafka.enabled=${KAFKA_ENABLED:false}

# Kafka Bootstrap Servers (можно переопределить через переменную окружения KAFKA_BOOTSTRAP_SERVERS)
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}

# Kafka Producer Configuration
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.acks=all
spring.kafka.producer.retries=3
# Таймауты для подключения (в миллисекундах)
spring.kafka.producer.properties[connection.max.idle.ms]=540000
spring.kafka.producer.properties[request.timeout.ms]=30000
spring.kafka.producer.properties[delivery.timeout.ms]=120000
# Не блокировать запуск приложения, если Kafka недоступен
spring.kafka.producer.properties[max.block.ms]=5000

# Kafka Consumer Configuration (для получения агрегированных данных)
spring.kafka.consumer.group-id=main-app-analytics-group
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.enable-auto-commit=true

# ===============================
# EMAIL / SMTP НАСТРОЙКИ
# ===============================

# SMTP Host (по умолчанию: MailHog для разработки)
# Для разработки: localhost (MailHog на порту 1025)
# Для продакшена: укажите SMTP сервер вашего провайдера (например, smtp.mailgun.org, smtp.sendgrid.net)
# Можно переопределить через переменную окружения SPRING_MAIL_HOST
spring.mail.host=${SPRING_MAIL_HOST:localhost}

# SMTP Port
# Для MailHog: 1025
# Для продакшена: обычно 587 (TLS) или 465 (SSL)
# Можно переопределить через переменную окружения SPRING_MAIL_PORT
spring.mail.port=${SPRING_MAIL_PORT:1025}

# SMTP Username (для продакшена)
# Для MailHog: не требуется (можно оставить пустым)
# Для продакшена: укажите username от вашего SMTP провайдера
# Можно переопределить через переменную окружения SPRING_MAIL_USERNAME
spring.mail.username=${SPRING_MAIL_USERNAME:}

# SMTP Password (для продакшена)
# Для MailHog: не требуется (можно оставить пустым)
# Для продакшена: укажите password от вашего SMTP провайдера
# ВАЖНО: Не коммитьте реальный пароль в репозиторий! Используйте переменную окружения SPRING_MAIL_PASSWORD
spring.mail.password=${SPRING_MAIL_PASSWORD:}

# Отправитель email (From address)
# Можно переопределить через переменную окружения SPRING_MAIL_FROM
# Пример: noreply@yourdomain.com
spring.mail.properties.mail.smtp.from=${SPRING_MAIL_FROM:noreply@localhost}

# Дополнительные настройки SMTP
# Для MailHog: не требуется аутентификация
# Для продакшена: обычно нужна аутентификация
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_SMTP_AUTH:false}

# TLS/SSL настройки
# Для MailHog: false
# Для продакшена: обычно true (для порта 587 используйте STARTTLS, для 465 - SSL)
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_SMTP_STARTTLS_ENABLE:false}
spring.mail.properties.mail.smtp.ssl.enable=${SPRING_MAIL_SMTP_SSL_ENABLE:false}

# Таймауты
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=5000

# Base URL для ссылок подтверждения email
# Можно переопределить через переменную окружения APP_EMAIL_VERIFICATION_BASE_URL
# Пример: http://localhost:8080 (для разработки) или https://yourdomain.com (для продакшена)
app.email.verification.base-url=${APP_EMAIL_VERIFICATION_BASE_URL:http://localhost:3000}

# Срок жизни токена верификации email (в часах)
# Можно переопределить через переменную окружения APP_EMAIL_VERIFICATION_TOKEN_EXPIRATION_HOURS
app.email.verification.token-expiration-hours=${APP_EMAIL_VERIFICATION_TOKEN_EXPIRATION_HOURS:24}

# ===============================
# НАСТРОЙКИ ВОССТАНОВЛЕНИЯ ПАРОЛЯ
# ===============================

# Время жизни токена восстановления пароля (в часах)
# Можно переопределить через переменную окружения APP_PASSWORD_RESET_TOKEN_EXPIRATION_HOURS
app.password.reset.token-expiration-hours=${APP_PASSWORD_RESET_TOKEN_EXPIRATION_HOURS:1}

# ===============================
# SPRING BOOT ACTUATOR НАСТРОЙКИ
# ===============================

# Включить endpoints
management.endpoints.web.exposure.include=health,metrics,prometheus,info
# Базовый путь для actuator endpoints
management.endpoints.web.base-path=/actuator
# Включить метрики для всех endpoints
# В Spring Boot 3.x+ метрики HTTP запросов включены по умолчанию через Observations API
management.observations.http.server.requests.name=http.server.requests
# Настройки для Prometheus
management.prometheus.metrics.export.enabled=true